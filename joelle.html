<!DOCTYPE html>
<html lang="fr">
<head>
    <title>Cours WebGL</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            padding: 0;
            margin : 0;
        }
    </style>
</head>

<body>
    <script type="module">
        import * as THREE from './three.module.js';

        import { OrbitControls } from './OrbitControls.js';

        var camera, scene, renderer, controls;
        var terrain, mesh, mesh2, mesh3, mesh4, mesh5, mesh6;
        var group = new THREE.Group();

        // Conversion des degrés en radians
        Math.radians = function (degrees) {
            return degrees * Math.PI / 180;
        };

        init();
        animate();

        function init() {

            //Scène et caméra
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 3000);
            /*camera.position.z = 100; //350 ou 0
            camera.position.y = 700; //100 ou 700
            camera.rotation.x -= 1.15; // 0.45 ou 1.15
            camera.position.x = -300;*/

            camera.position.z = 550;
            camera.position.y = 100;
            camera.rotation.x -= 0.45;

            var geometry, wall, tower, roof;

            // Textures
            var textMur = new THREE.TextureLoader().load('./tex/stone wall 7.png');
            var textRempart = new THREE.TextureLoader().load('./tex/stone wall 7.png');
            var textGrass = new THREE.TextureLoader().load('./tex/grass1.png');
            var textPorte = new THREE.TextureLoader().load('./tex/door.jpg');
            var textGate = new THREE.TextureLoader().load('./tex/stone wall 7.png');
            var textToit = new THREE.TextureLoader().load('./tex/roof.jpg');
            var textWindow = new THREE.TextureLoader().load('./tex/window.jpg');
            var textSky = new THREE.TextureLoader().load('./tex/sky.jpg');
            textRempart.wrapS = THREE.RepeatWrapping;
            textRempart.wrapT = THREE.RepeatWrapping;
            textRempart.repeat.set(0.5, 0.25);
            textMur.wrapS = THREE.RepeatWrapping;
            textMur.wrapT = THREE.RepeatWrapping;
            textMur.repeat.set(4, 2);
            textGate.wrapS = THREE.RepeatWrapping;
            textGate.wrapT = THREE.RepeatWrapping;
            textGate.repeat.set(2, 2);
            textToit.wrapS = THREE.RepeatWrapping;
            textToit.wrapT = THREE.RepeatWrapping;
            textToit.repeat.set(2, 1);
            textGrass.wrapS = THREE.RepeatWrapping;
            textGrass.wrapT = THREE.RepeatWrapping;
            textGrass.repeat.set(80, 80);
            var materialMur = new THREE.MeshBasicMaterial({map: textMur});
            var materialRempart = new THREE.MeshBasicMaterial({map: textRempart});
            var materialGrass = new THREE.MeshBasicMaterial({map: textGrass});
            var materialPorte = new THREE.MeshBasicMaterial({map: textPorte});
            var materialGate = new THREE.MeshBasicMaterial({map: textGate});
            var materialToit = new THREE.MeshBasicMaterial({map: textToit});
            var materialWindow = new THREE.MeshBasicMaterial({map: textWindow});

            // Terrain
            geometry = new THREE.PlaneGeometry(3000, 3000);
            terrain = new THREE.Mesh(geometry, materialGrass);
            terrain.rotateX(Math.radians(-90));
            scene.add(terrain);


            // Muraille avant
            var mainGate = new THREE.Group();
            var mainGateWidth = 90;
            var mainGateHeight = 200;
            var wallDepth = 10;
            var towerWidth = 20;
            var towerHeight = 230;
            var roofHeight = 20;
            wall = new THREE.Mesh(new THREE.BoxBufferGeometry(mainGateWidth, mainGateHeight, wallDepth), materialMur);
            mainGate.add(wall.clone());
            var door = new THREE.Mesh(new THREE.BoxBufferGeometry(40, 40, wallDepth), materialPorte);
            door.position.set(0, 20, 0);
            mainGate.add(door.clone());
            tower = new THREE.Mesh(new THREE.CylinderBufferGeometry(towerWidth, towerWidth, towerHeight, 32), materialMur);
            tower.position.set(mainGateWidth/2 + towerWidth, 0, 0);
            mainGate.add(tower.clone());
            tower.position.set(-(mainGateWidth/2 + towerWidth), 0, 0);
            mainGate.add(tower.clone());
            roof = new THREE.Mesh(new THREE.CylinderBufferGeometry(1, towerWidth + 10, roofHeight, 32), materialToit);
            roof.position.set(mainGateWidth/2 + towerWidth, towerHeight/2 + roofHeight/2, 0);
            mainGate.add(roof.clone());
            roof.position.set(-(mainGateWidth/2 + towerWidth), towerHeight/2 + roofHeight/2, 0);
            mainGate.add(roof.clone());
            var wallRoof = new THREE.Mesh(new THREE.BoxBufferGeometry(mainGateWidth, 10, 10), materialToit);
            wallRoof.position.set(0, mainGateHeight / 2, 0);
            wallRoof.rotateX(Math.radians(45));
            mainGate.add(wallRoof.clone());

            // Enceinte
            var outerWall = new THREE.Group();
            var width = 150;
            var refX = -width;
            var refZ;
            var crenel;

            wall = new THREE.Mesh(new THREE.BoxBufferGeometry(width, mainGateHeight/1.2, wallDepth), materialMur);
            wall.position.set(refX, 0, 0);
            outerWall.add(wall.clone());
            refX -= width/2;

            tower = new THREE.Mesh(new THREE.CylinderBufferGeometry(towerWidth, towerWidth, towerHeight, 32), materialMur);
            tower.position.set(refX, 0, 0);
            outerWall.add(tower.clone());
            refX -= towerWidth/2;

            width = 230;
            refX -= width / 2 - 20;
            refZ = -70;
            wall = new THREE.Mesh(new THREE.BoxBufferGeometry(width, mainGateHeight/1.2, wallDepth), materialMur);
            wall.position.set(refX, 0, refZ);
            wall.rotateY(Math.radians(-35)); //20
            outerWall.add(wall.clone());




            refX -= 120;
            refZ -= 80;
            tower = new THREE.Mesh(new THREE.CylinderBufferGeometry(towerWidth, towerWidth, towerHeight, 32), materialMur);
            tower.position.set(refX, 0, refZ);
            outerWall.add(tower.clone());
            roof = new THREE.Mesh(new THREE.CylinderBufferGeometry(1, towerWidth + 10, roofHeight, 32), materialToit);
            roof.position.set(refX, towerHeight/2 + roofHeight/2, refZ);
            mainGate.add(roof.clone());


            for (var xCrenel = refX ; xCrenel < refX + width ; xCrenel -= 30) {
                crenel = new THREE.Mesh(new THREE.BoxBufferGeometry(10, 10, 10), materialMur);
                crenel.position.set(xCrenel, 200, 0);
                outerWall.add(crenel.clone());
            }

            width = 150;
            refZ -= width/2;
            wall = new THREE.Mesh(new THREE.BoxBufferGeometry(width, mainGateHeight/1.2, wallDepth), materialMur);
            wall.position.set(refX, 0, refZ);
            wall.rotateY(Math.radians(-90));
            outerWall.add(wall.clone());

            refZ -= width/2;
            tower = new THREE.Mesh(new THREE.CylinderBufferGeometry(towerWidth, towerWidth, towerHeight, 32), materialMur);
            tower.position.set(refX, 0, refZ);
            outerWall.add(tower.clone());

            width = 250;
            refZ -= width/2;
            wall = new THREE.Mesh(new THREE.BoxBufferGeometry(width, mainGateHeight/1.2, wallDepth), materialMur);
            wall.position.set(refX, 0, refZ);
            wall.rotateY(Math.radians(-90));
            outerWall.add(wall.clone());

            refZ -= width/2;
            tower = new THREE.Mesh(new THREE.CylinderBufferGeometry(towerWidth, towerWidth, towerHeight, 32), materialMur);
            tower.position.set(refX, 0, refZ);
            outerWall.add(tower.clone());
            roof = new THREE.Mesh(new THREE.CylinderBufferGeometry(1, towerWidth + 10, roofHeight, 32), materialToit);
            roof.position.set(refX, towerHeight/2 + roofHeight/2, refZ);
            mainGate.add(roof.clone());

            width = 350;
            refX += width/2;
            wall = new THREE.Mesh(new THREE.BoxBufferGeometry(width, mainGateHeight/1.2, wallDepth), materialMur);
            wall.position.set(refX, 0, refZ);
            outerWall.add(wall.clone());

            refX += width/2;
            tower = new THREE.Mesh(new THREE.CylinderBufferGeometry(towerWidth, towerWidth, towerHeight, 32), materialMur);
            tower.position.set(refX, 0, refZ);
            outerWall.add(tower.clone());

            width = 250;
            refX += width/2;
            refZ += 80;
            wall = new THREE.Mesh(new THREE.BoxBufferGeometry(width, mainGateHeight/1.2, wallDepth), materialMur);
            wall.position.set(refX, 0, refZ);
            wall.rotateY(Math.radians(-30));
            outerWall.add(wall.clone());

            refX += width/2;
            refZ += 70;
            tower = new THREE.Mesh(new THREE.CylinderBufferGeometry(towerWidth, towerWidth, towerHeight, 32), materialMur);
            tower.position.set(refX, 0, refZ);
            outerWall.add(tower.clone());
            roof = new THREE.Mesh(new THREE.CylinderBufferGeometry(1, towerWidth + 10, roofHeight, 32), materialToit);
            roof.position.set(refX, towerHeight/2 + roofHeight/2, refZ);
            mainGate.add(roof.clone());

            width = 150;
            refX += width/2 - 40;
            refZ += 80;
            wall = new THREE.Mesh(new THREE.BoxBufferGeometry(width, mainGateHeight/1.2, wallDepth), materialMur);
            wall.position.set(refX, 0, refZ);
            wall.rotateY(Math.radians(-70));
            outerWall.add(wall.clone());

            refX += width/2 - 40;
            refZ += 80;
            tower = new THREE.Mesh(new THREE.CylinderBufferGeometry(towerWidth, towerWidth, towerHeight, 32), materialMur);
            tower.position.set(refX, 0, refZ);
            outerWall.add(tower.clone());

            width = 290;
            refZ += 120;
            refX -= 70;
            wall = new THREE.Mesh(new THREE.BoxBufferGeometry(width, mainGateHeight/1.2, wallDepth), materialMur);
            wall.position.set(refX, 0, refZ);
            wall.rotateY(Math.radians(55));
            outerWall.add(wall.clone());











            // Affichage

            instanceToScene(mainGate);
            instanceToScene(outerWall);


            group.add(terrain);


            // Rendu
            scene.background = textSky;
            renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            window.addEventListener('resize', onWindowResize, false);

            controls = new OrbitControls( camera, renderer.domElement );
            controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 100;
            controls.maxDistance = 500;
            controls.maxPolarAngle = Math.PI / 2;
        }

        function instanceToScene(mesh) {
            if (mesh !== undefined) {
                group.add(mesh.clone());
            }
            scene.add(group);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            //group.rotation.y += 0.002;
            controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true
            renderer.render(scene, camera);
        }

    </script>
</body>
</html>